1. O(log n)
Since we are iterating through n number of elements, and each iteration we are divinding the set into two which makes it O(log n)
2. O(n)
There are two loops, one iterating through all n linearly and one splitting the data, the other iterating based on some other value. Since the first loop is the only one comparing to n, it is O(n)
3. O(nlog n)
Since one loop is inside another, we multiply. doIt() runs in log n time since its dividing the number of elements each iteration. and the for loop goes n times. So it is O(nlog n)
4. O(nlog n)
The outer loop is takeing directly the number of values and comparing and halving each time making it O(log n), the inner is going through linearly O(n) times, multiplying the two we get O(nlog n)
5. O(c)
No matter the number that n is, the while loop will never be executed with n elements, since it's never executed it is O(c)
6. loopIt O(c)
The loopIt function it self has no reference to n elements, there for it never makes a reference to n, which means it runs in constant time
6b. Overall O(c)
The Overall run time is O(c) since the only operations that are being performed are equating, and since loopIt runs in constant time, the whole program runs in constant time
7. O(sqrt(n))
Since the number of times the loop must iterate is based on n, the internals of the loop have a relation to one another being the sqrt(sum) == i value, making this O(sqrt(n))
8. O(nlog n)
The outer loop runs in O(n) since it iterates over all n, however the inner loop and its equation are halving the amount of elements to run through each time making it log n, multiplying gives you O(nlog n)
9. O(nlog n)
The most outer loop is running and dividing the items in half each time, the inner loop is iterating over all n elements, multiplying to get O(nlog n)
